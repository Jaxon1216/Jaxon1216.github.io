{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Jaxon","url":"https://jaxon1216.github.io","root":"/"},"pages":[{"title":"Books","date":"2024-12-31T16:00:00.000Z","updated":"2025-08-14T05:26:08.561Z","comments":true,"path":"books/index.html","permalink":"https://jaxon1216.github.io/books/index.html","excerpt":"","text":"毛泽东选集"},{"title":"Links","date":"2024-12-31T16:00:00.000Z","updated":"2025-08-14T05:21:14.850Z","comments":true,"path":"links/index.html","permalink":"https://jaxon1216.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2025-08-06T13:56:37.802Z","updated":"2025-08-06T13:56:37.802Z","comments":false,"path":"repository/index.html","permalink":"https://jaxon1216.github.io/repository/index.html","excerpt":"","text":""},{"title":"Archives","date":"2024-12-31T16:00:00.000Z","updated":"2025-08-14T07:27:48.945Z","comments":true,"path":"archives/index.html","permalink":"https://jaxon1216.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2025-08-03T12:40:48.000Z","updated":"2025-08-04T12:18:33.828Z","comments":true,"path":"about/index.html","permalink":"https://jaxon1216.github.io/about/index.html","excerpt":"","text":"欢迎来到我的博客！这里是我的个人简介和一些关于我的信息。"},{"title":"Categories","date":"2024-12-31T16:00:00.000Z","updated":"2025-08-14T07:29:28.526Z","comments":true,"path":"categories/index.html","permalink":"https://jaxon1216.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-12-31T16:00:00.000Z","updated":"2025-08-14T05:21:11.186Z","comments":true,"path":"tags/index.html","permalink":"https://jaxon1216.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"August","slug":"August","date":"2025-08-14T07:32:32.000Z","updated":"2025-08-14T08:37:36.890Z","comments":true,"path":"2025/08/14/August/","permalink":"https://jaxon1216.github.io/2025/08/14/August/","excerpt":"","text":"线代：姜晓千+研掌 数据结构：英雄cpp + 严蔚敏 英语：发音youtuber（english with ronnie），记单词15min，一分钟口语录音 减脂：控制饮食，五分化训练 日期 天气 记录和总结 2025-08-14 晴 做了今天到开学学习和健身规划，蓄势待发 2025-08-15 2025-08-16 2025-08-17 2025-08-18 2025-08-19 2025-08-20 2025-08-21 2025-08-22 2025-08-23 2025-08-24 2025-08-25 2025-08-26 2025-08-27 2025-08-28 2025-08-29 2025-08-30 2025-08-31","categories":[{"name":"diary","slug":"diary","permalink":"https://jaxon1216.github.io/categories/diary/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://jaxon1216.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"my learning materials","slug":"my-study-materials","date":"2025-08-14T06:02:13.000Z","updated":"2025-08-14T13:01:20.221Z","comments":true,"path":"2025/08/14/my-study-materials/","permalink":"https://jaxon1216.github.io/2025/08/14/my-study-materials/","excerpt":"","text":"作者blog：jx’s blog github地址：cpp-notes to do list 考研最全汇总 公共课(数学英语政治)链接:https://pan.baidu.com/s/1tlwPi-Gtxti8OUYEy7Ec7g?pwd=6666 专业课链接:https://pan.baidu.com/s/1lEggoQwjXgxpLEdtBK1kuw?pwd=hvjn 提取码: hvjn English summarize链接:https://kdocs.cn/l/cnddY5m0PNQw Code 抖音英雄链接:https://pan.baidu.com/s/1F79nOTr-lSiADpp8n5AhrQ?pwd=mkd5 c++primer链接:https://pan.baidu.com/s/1t39Cc-P5L6QxCmbqqgAF9A?pwd=m0rq 数据结构严蔚敏链接:https://pan.baidu.com/s/1wG_6mUkq0fZdXZvoBV3pTg?pwd=bjsg 提取码: bjsg","categories":[{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"资料","slug":"资料","permalink":"https://jaxon1216.github.io/tags/%E8%B5%84%E6%96%99/"}]},{"title":"资料汇总","slug":"资料汇总","date":"2025-08-04T14:49:10.000Z","updated":"2025-08-14T07:43:04.051Z","comments":true,"path":"2025/08/04/资料汇总/","permalink":"https://jaxon1216.github.io/2025/08/04/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/","excerpt":"","text":"作者blog：jx’s blog github地址：cpp-notes 本文件是除了群文件内容，本人用过的链接形式的资料 所有售卖行为都与本人无关，如若遇到倒卖行为请联系我 q2392452065 群文件展示（后续会更新外刊等）q群号1046446925 English 史上最全 极力推荐！！！链接:https://kdocs.cn/l/cnddY5m0PNQw Code 抖音英雄链接:https://pan.baidu.com/s/1F79nOTr-lSiADpp8n5AhrQ?pwd=mkd5 c++primer链接:https://pan.baidu.com/s/1t39Cc-P5L6QxCmbqqgAF9A?pwd=m0rq 数据结构严蔚敏链接:https://pan.baidu.com/s/1wG_6mUkq0fZdXZvoBV3pTg?pwd=bjsg 提取码: bjsg 数学建模这一块 较全的资源链接: https://pan.baidu.com/s/11dGFB_eFxmmhOgeUBDNJ1w?pwd=u7ef提取码: u7ef（复制这段内容后打开百度网盘手机App，操作更方便哦） 大师兄数学建模链接：https://pan.baidu.com/s/13b756L-IxbSkVxFBHY12GA提取码：3xjx 清风数学建模论文课件下载链接：https://pan.baidu.com/s/1H5nULaZip_kUuEMI07R0Pg?pwd=jmz9提取码: jmz9 建模老哥数学建模算法、编程、写作课件链接: https://pan.baidu.com/s/1hWrNSUobVV8vI8zc7381Rg?pwd=1020提取码: 1020 mathmatics 除了群文件的，本人略有一些成果：【腾讯文档】高等数学上册思维导图及公式汇总链接：https://docs.qq.com/mind/DRnROeGNxTVFPdndK?mode=mind 禁二传 26张宇基础30讲复制整段内容，打开最新版「夸克APP」即可获取链接：https://pan.quark.cn/s/4c425e839d51 考研真相链接: https://pan.baidu.com/s/1mmp2vJbaR3gpBObRAIquqA提取码: euas 保研这一块 夏令营和预推免通知网站（通知全量实时更新）：Github：https://github.com/shenyanpai/awesome-summer-camp-2025Gitee：https://gitee.com/shenyanpai/awesome-summer-camp-2025","categories":[{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"资料汇总","slug":"资料汇总","permalink":"https://jaxon1216.github.io/tags/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"},{"name":"学习资源","slug":"学习资源","permalink":"https://jaxon1216.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"},{"name":"编程","slug":"编程","permalink":"https://jaxon1216.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"数学建模","slug":"数学建模","permalink":"https://jaxon1216.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"英语","slug":"英语","permalink":"https://jaxon1216.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"保研","slug":"保研","permalink":"https://jaxon1216.github.io/tags/%E4%BF%9D%E7%A0%94/"}]},{"title":"C++基础知识","slug":"基础知识","date":"2025-08-04T14:29:24.000Z","updated":"2025-08-14T06:28:05.546Z","comments":true,"path":"2025/08/04/基础知识/","permalink":"https://jaxon1216.github.io/2025/08/04/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"目录 C++基础概念 面向对象编程 理论知识点 C++基础概念结构体结构体定义和使用：结构体是一种自定义的数据类型，可以包含多个不同类型的成员变量。 结构体的定义格式： 1234567struct 结构体名&#123; 成员变量类型1 成员变量名1; 成员变量类型2 成员变量名2; ... 成员变量类型n 成员变量名n;&#125;; 基础示例： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Student&#123; int id; //学号 string name; //姓名 int age; //年龄&#125;;int main()&#123; Student stu; //在c++中可以省略struct关键字 stu.id = 1001; stu.name = &quot;张三&quot;; stu.age = 18; cout &lt;&lt; &quot;学号：&quot; &lt;&lt; stu.id &lt;&lt; endl; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu.name &lt;&lt; endl; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; stu.age &lt;&lt; endl; return 0;&#125; 结构体数组： 12345Student stu[3] = &#123; &#123;1001, &quot;张三&quot;, 18&#125;, &#123;1002, &quot;李四&quot;, 19&#125;, &#123;1003, &quot;王五&quot;, 20&#125;&#125;; 结构体指针： 123Student stu = &#123;1001, &quot;张三&quot;, 18&#125;;Student *p = &amp;stu; //定义结构体指针p，指向结构体变量stucout &lt;&lt; &quot;学号：&quot; &lt;&lt; p-&gt;id &lt;&lt; endl; //通过指针访问结构体成员变量 指针指针定义和使用： 1234int a = 10, b = 20;int *p1 = &amp;a, *p2 = &amp;b; // 定义指针变量p1和p2，分别指向a和bcout &lt;&lt; &quot;*p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl; //指针变量前加*，表示取出指针变量指向的内存中的值cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; endl; //指针变量前不加*，表示取出指针变量本身的值，即内存编号 空指针和野指针： 12345int *p = NULL; //定义空指针//cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; //空指针不能访问内存中的值，会报错int *p = (int *)0x7ffebc1b3b7c; //定义野指针//cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; //野指针不能访问内存中的值，会报错 const修饰指针： 12const int *p = &amp;a; //指向常量的指针，不能修改指向的值int *const p = &amp;a; //指针常量，不能修改指针指向的地址 函数函数声明和定义： 1234int max (int a, int b); // 函数声明int max (int a, int b) &#123; // 函数定义 return a &gt; b ? a : b; // 三目运算符&#125; 值传递vs引用传递： 12345678910111213// 值传递（不会改变原值）void swap(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;// 引用传递（会改变原值）void swap(int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp;&#125; 数组一维数组： 12345678910111213141516171819202122232425262728293031int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;// 找出最大值int max = arr[0];for(int i = 0; i &lt; 10; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; &#125;&#125;// 元素逆置int start = 0;int end = sizeof(arr)/sizeof(arr[0]) - 1;while(start &lt; end)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--;&#125;// 冒泡排序for(int i = 0; i &lt; 10; i++)&#123; for(int j = 0; j &lt; 10 - i - 1; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125; 二维数组： 12345678910111213// 四种定义方式int arr1[2][3]; // 1. 数据类型 数组名[行数][列数];int arr2[2][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; // 2. 数据类型 数组名[行数][列数] = &#123;&#123;数据1，数据2&#125;,&#123;数据3，数据4&#125;&#125;;int arr3[2][3] = &#123;1,2,3,4,5,6&#125;; // 3. 数据类型 数组名[行数][列数] = &#123;数据1，数据2，数据3，数据4&#125;;int arr4[][3] = &#123;1,2,3,4,5,6&#125;; // 4. 数据类型 数组名[][列数] = &#123;数据1，数据2，数据3，数据4&#125;;// 输出二维数组for (int i = 0; i &lt; 2; i++)&#123; for (int j = 0; j &lt; 3; j++)&#123; cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 面向对象编程类和对象创建类： 12345class MyClass &#123; public: // 访问修饰符指定可以从类外部访问类的成员 int myNum; // 属性（int 变量） string myString; // 属性（string 变量）&#125;; 创建对象： 12345678910111213141516class Car &#123; public: string brand; string model; int year;&#125;;int main() &#123; Car carObj1; carObj1.brand = &quot;BMW&quot;; carObj1.model = &quot;X5&quot;; carObj1.year = 1999; cout &lt;&lt; carObj1.brand &lt;&lt; &quot; &quot; &lt;&lt; carObj1.model &lt;&lt; &quot; &quot; &lt;&lt; carObj1.year &lt;&lt; &quot;\\n&quot;; return 0;&#125; 类方法内部定义： 123456789101112class MyClass &#123; public: void myMethod() &#123; cout &lt;&lt; &quot;Hello World!&quot;; &#125;&#125;;int main() &#123; MyClass myObj; myObj.myMethod(); return 0;&#125; 外部定义： 123456789class MyClass &#123; public: void myMethod(); // 方法声明&#125;;// 类外的方法定义void MyClass::myMethod() &#123; cout &lt;&lt; &quot;Hello World!&quot;;&#125; 构造函数内部定义： 12345678910111213141516class Car &#123; public: string brand; string model; int year; Car(string x, string y, int z) &#123; // 带参数的构造函数 brand = x; model = y; year = z; &#125;&#125;;int main() &#123; Car carObj1(&quot;BMW&quot;, &quot;X5&quot;, 1999); return 0;&#125; 外部定义： 1234567891011121314class Car &#123; public: string brand; string model; int year; Car(string x, string y, int z); // 构造函数声明&#125;;// 类外的构造函数定义Car::Car(string x, string y, int z) &#123; brand = x; model = y; year = z;&#125; 访问修饰符在C++中，有三个访问修饰符： public - 成员可以从类外访问 private - 不能从类外部访问（或查看）成员 protected - 不能从类外部访问成员，但是可以在继承的类中访问成员 默认情况下，如果不指定访问修饰符，则类的所有成员都是私有的private。 12345678910111213class MyClass &#123; public: // 公共访问修饰符 int x; // 公共属性 private: // 私有访问修饰符 int y; // 私有属性&#125;;int main() &#123; MyClass myObj; myObj.x = 25; // 允许 (public) // myObj.y = 50; // 不允许 (private) return 0;&#125; 封装封装的意义是确保对用户隐藏敏感数据。为此，必须将类变量&#x2F;属性声明为private。 123456789101112131415161718192021class Employee &#123; private: int salary; // 私有属性 public: // Setter void setSalary(int s) &#123; salary = s; &#125; // Getter int getSalary() &#123; return salary; &#125;&#125;;int main() &#123; Employee myObj; myObj.setSalary(50000); cout &lt;&lt; myObj.getSalary(); return 0;&#125; 继承继承对代码的可重用性很有用：在创建新类时重用现有类的属性和方法。 123456789101112131415161718192021// 基类class Vehicle &#123; public: string brand = &quot;Ford&quot;; void honk() &#123; cout &lt;&lt; &quot;Tuut, tuut! \\n&quot;; &#125;&#125;;// 派生类class Car: public Vehicle &#123; public: string model = &quot;Mustang&quot;;&#125;;int main() &#123; Car myCar; myCar.honk(); cout &lt;&lt; myCar.brand + &quot; &quot; + myCar.model; return 0;&#125; 多态多态允许我们执行一个动作，以不同的方式。 12345678910111213141516171819202122232425262728293031323334// 基类class Animal &#123; public: void animalSound() &#123; cout &lt;&lt; &quot;The animal makes a sound \\n&quot;; &#125;&#125;;// 派生类class Pig : public Animal &#123; public: void animalSound() &#123; cout &lt;&lt; &quot;The pig says: wee wee \\n&quot;; &#125;&#125;;// 派生类class Dog : public Animal &#123; public: void animalSound() &#123; cout &lt;&lt; &quot;The dog says: bow wow \\n&quot;; &#125;&#125;;int main() &#123; Animal myAnimal; Pig myPig; Dog myDog; myAnimal.animalSound(); myPig.animalSound(); myDog.animalSound(); return 0;&#125; 理论知识点类和对象相关 类成员访问权限：默认情况下，类中的数据成员是private的 类定义包含：数据和函数成员的定义 对象成员函数调用：使用点语法，如 x.a() 对象生命周期：对象生命期结束时，系统自动调用析构函数并销毁对象 函数相关 形参：形参可以有也可以没有，不是必须的 函数重载：编译器会根据函数的参数个数和参数类型来区分函数的重载形式 内联函数：inline是编译优化建议，与定义位置无关 函数声明：仅当函数定义在调用之后时需要声明 字符串处理 字符串比较：使用 strcmp(s1,s2)&gt;0 判断字符串s1是否大于字符串s2 字符函数： isdigit() - 检查数字字符（0-9） isalnum() - 检查字母或数字字符 islower() - 检查小写字母（a-z） isupper() - 检查大写字母（A-Z） isspace() - 检查空白字符 ispunct() - 检查标点符号 isprint() - 检查可打印字符 控制结构 break语句：最常用的是在循环语句中的if语句里，满足条件时跳出循环 continue语句：跳过本次循环，继续下一次循环 循环嵌套：外层循环控制轮数，内层循环控制每轮次数 数据类型和转换 类型转换：注意隐式转换和显式转换的区别 精度问题：浮点数运算可能存在精度误差 内存管理：指针使用需要注意内存泄漏和野指针问题 常用函数和技巧数学函数123456#include &lt;cmath&gt;ceil(2.4) // 向上取整，得到3floor(2.7) // 向下取整，得到2abs(-5) // 绝对值，得到5pow(2, 3) // 幂运算，2的3次方，得到8sqrt(16) // 平方根，得到4 字符串处理1234567#include &lt;string&gt;#include &lt;algorithm&gt;string s = &quot;hello&quot;;reverse(s.begin(), s.end()); // 反转字符串s.length() // 字符串长度s.substr(0, 3) // 子串，从位置0开始，长度为3 字符处理1234567#include &lt;cctype&gt;char c = &#x27;a&#x27;;toupper(c) // 转换为大写tolower(c) // 转换为小写isdigit(c) // 判断是否为数字isalpha(c) // 判断是否为字母 输入输出格式控制1234#include &lt;iomanip&gt;cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; 3.14159; // 输出3.142cout &lt;&lt; setw(10) &lt;&lt; &quot;hello&quot;; // 设置输出宽度为10","categories":[{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://jaxon1216.github.io/tags/C/"}]},{"title":"洛谷题集-入门","slug":"洛谷题集","date":"2025-08-04T14:26:51.000Z","updated":"2025-08-14T06:28:28.296Z","comments":true,"path":"2025/08/04/洛谷题集/","permalink":"https://jaxon1216.github.io/2025/08/04/%E6%B4%9B%E8%B0%B7%E9%A2%98%E9%9B%86/","excerpt":"","text":"洛谷题目集目录 数组题目 字符串题目 循环题目 分支题目 顺序题目 数组题目神奇的幻方题目描述： 构造一个n×n的幻方，满足每行、每列、两条对角线的和都相等。 解题思路： 使用幻方的构造规则，从第一行中间开始，按照特定规则填充数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int a[45][45] = &#123;&#125;; // 幻方数组，初始化为0 int k = 1; // 当前要填入的数字 int x, y; // 当前数字的位置 while (k &lt;= n * n) &#123; // 循环直到填满所有数字 if (k == 1) &#123; // 第一个数字放在第一行的中间 x = 1; y = n / 2 + 1; &#125; else &#123; // 根据幻方规则移动位置 if (x == 1 &amp;&amp; y != n) &#123; // 如果在第一行且不在最后一列 x = n; // 移动到最后一行 y++; // 列向右移动 &#125; else if (y == n &amp;&amp; x != 1) &#123; // 如果在最后一列且不在第一行 x--; // 行向上移动 y = 1; // 移动到第一列 &#125; else if (x == 1 &amp;&amp; y == n) &#123; // 如果在第一行最后一列 x++; // 行向下移动 &#125; else &#123; if (a[x-1][y+1] != 0) &#123; // 如果右上角已经有数字 x++; // 行向下移动 &#125; else &#123; x--; // 行向上移动 y++; // 列向右移动 &#125; &#125; &#125; a[x][y] = k; // 填入数字 k++; // 下一个数字 &#125; // 输出幻方 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 杨辉三角题目描述： 输入n，输出前n行的杨辉三角。 解题思路： 使用二维数组存储，每个数等于它上方两个数之和。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; yanghui(n); for(int i = 0; i &lt; n; i++)&#123; yanghui[i].resize(i + 1); // 每行的元素个数为 i+1 yanghui[i][0] = yanghui[i][i] = 1; // 每行的第一个和最后一个元素为1 for(int j = 1; j &lt; i; j++)&#123; yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; cout &lt;&lt; yanghui[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 优化版本（仅输出）： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; int val = 1; for(int j = 0; j &lt;= i; j++)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; val = val * (i - j) / (j + 1); // 计算下一个值 &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 蛇形方阵题目描述： 构造一个n×n的蛇形方阵，数字从1开始按蛇形路径填充。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int a[100][100] = &#123;&#125;; int num = 1; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; // 偶数行从左到右 for (int j = 0; j &lt; n; j++) &#123; a[i][j] = num++; &#125; &#125; else &#123; // 奇数行从右到左 for (int j = n - 1; j &gt;= 0; j--) &#123; a[i][j] = num++; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 开灯问题题目描述： 有n盏灯，编号为1到n。第1个人把所有灯都打开，第2个人按下所有编号为2的倍数的开关，第3个人按下所有编号为3的倍数的开关，以此类推。问最后有多少盏灯是亮的。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;bool&gt; lights(n + 1, false); // false表示灯关闭 for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j += i) &#123; lights[j] = !lights[j]; // 翻转灯的状态 &#125; &#125; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; if (lights[i]) count++; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 珠心算测验题目描述： 给定n个数，问有多少个数可以表示为其他两个数的和。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n); vector&lt;bool&gt; canSum(20001, false); // 标记哪些数可以表示为两数之和 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; // 计算所有可能的和 for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; canSum[nums[i] + nums[j]] = true; &#125; &#125; int count = 0; for (int i = 0; i &lt; n; i++) &#123; if (canSum[nums[i]]) count++; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 字符串题目数字反转题目描述： 给定一个数，可以是整数、小数、分数或百分数，请将该数各个位上数字反转得到一个新数。 解题思路： 根据不同的数字类型分别处理，注意去除前导零和末尾零。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 反转字符串，并去除前导零string reverseStr(string s) &#123; reverse(s.begin(), s.end()); // 去除前导零 s.erase(0, s.find_first_not_of(&#x27;0&#x27;)); // 如果全部是0，保留一个0 if (s.empty()) s = &quot;0&quot;; return s;&#125;int main() &#123; string s; cin &gt;&gt; s; // 判断输入类型 if (s.find(&#x27;.&#x27;) != string::npos) &#123; // 小数 int pos = s.find(&#x27;.&#x27;); string intPart = s.substr(0, pos); string decPart = s.substr(pos + 1); // 反转整数部分和小数部分 string newInt = reverseStr(intPart); string newDec = reverseStr(decPart); // 去除小数部分末尾的0 newDec.erase(newDec.find_last_not_of(&#x27;0&#x27;) + 1); if (newDec.empty()) newDec = &quot;0&quot;; // 如果小数部分全为0，保留一个0 cout &lt;&lt; newInt &lt;&lt; &quot;.&quot; &lt;&lt; newDec &lt;&lt; endl; &#125; else if (s.find(&#x27;/&#x27;) != string::npos) &#123; // 分数 int pos = s.find(&#x27;/&#x27;); string numerator = s.substr(0, pos); string denominator = s.substr(pos + 1); // 反转分子和分母 string newNum = reverseStr(numerator); string newDen = reverseStr(denominator); cout &lt;&lt; newNum &lt;&lt; &quot;/&quot; &lt;&lt; newDen &lt;&lt; endl; &#125; else if (s.find(&#x27;%&#x27;) != string::npos) &#123; // 百分数 string num = s.substr(0, s.length() - 1); string newNum = reverseStr(num); cout &lt;&lt; newNum &lt;&lt; &quot;%&quot; &lt;&lt; endl; &#125; else &#123; // 整数 string newNum = reverseStr(s); cout &lt;&lt; newNum &lt;&lt; endl; &#125; return 0;&#125; 凯撒密码题目描述： 将字符串中的每个字母向后移动k位，非字母字符保持不变。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s; int k; cin &gt;&gt; s &gt;&gt; k; for (char&amp; c : s) &#123; if (isalpha(c)) &#123; char base = isupper(c) ? &#x27;A&#x27; : &#x27;a&#x27;; c = (c - base + k) % 26 + base; &#125; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 统计单词数题目描述： 统计一个单词在文本中出现的次数。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string word, text; getline(cin, word); getline(cin, text); // 转换为小写 transform(word.begin(), word.end(), word.begin(), ::tolower); transform(text.begin(), text.end(), text.begin(), ::tolower); stringstream ss(text); string token; int count = 0; int firstPos = -1; int currentPos = 0; while (ss &gt;&gt; token) &#123; if (token == word) &#123; count++; if (firstPos == -1) &#123; firstPos = currentPos; &#125; &#125; currentPos++; &#125; if (count == 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; count &lt;&lt; &quot; &quot; &lt;&lt; firstPos &lt;&lt; endl; &#125; return 0;&#125; 大小写转换题目描述： 将字符串中的大写字母转换为小写，小写字母转换为大写。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; for (char&amp; c : s) &#123; if (isupper(c)) &#123; c = tolower(c); &#125; else if (islower(c)) &#123; c = toupper(c); &#125; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 标题统计题目描述： 统计一行文本中字符的个数（不包括空格和换行符）。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s; getline(cin, s); int count = 0; for (char c : s) &#123; if (c != &#x27; &#x27; &amp;&amp; c != &#x27;\\n&#x27;) &#123; count++; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 循环题目冰雹猜想题目描述： 对于任意一个正整数，如果是奇数，则乘3加1；如果是偶数，则除以2。重复这个过程，最终会得到1。 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; while (n != 1) &#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; if (n % 2 == 1) &#123; n = n * 3 + 1; &#125; else &#123; n = n / 2; &#125; &#125; cout &lt;&lt; 1 &lt;&lt; endl; return 0;&#125; 梦中的统计题目描述： 统计数字0-9在给定范围内出现的次数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;int&gt; count(10, 0); for (int i = m; i &lt;= n; i++) &#123; int num = i; while (num &gt; 0) &#123; count[num % 10]++; num /= 10; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; count[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 门外的树题目描述： 有n棵树，编号为1到n。每次砍掉一段连续的树，问最后剩下多少棵树。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;bool&gt; trees(n + 1, true); // true表示树还在 for (int i = 0; i &lt; m; i++) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; for (int j = l; j &lt;= r; j++) &#123; trees[j] = false; // 砍掉树 &#125; &#125; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; if (trees[i]) count++; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125; 分支题目旗鼓相当的对手题目描述： 给定n个人的成绩，找出成绩相同的人数最多的成绩。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; scores(n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; scores[i]; &#125; sort(scores.begin(), scores.end()); int maxCount = 1; int currentCount = 1; int result = scores[0]; for (int i = 1; i &lt; n; i++) &#123; if (scores[i] == scores[i-1]) &#123; currentCount++; &#125; else &#123; if (currentCount &gt; maxCount) &#123; maxCount = currentCount; result = scores[i-1]; &#125; currentCount = 1; &#125; &#125; // 检查最后一组 if (currentCount &gt; maxCount) &#123; maxCount = currentCount; result = scores[n-1]; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 不知大小题目描述： 给定三个数，输出它们的最大值和最小值。 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int max_val = max(&#123;a, b, c&#125;); int min_val = min(&#123;a, b, c&#125;); cout &lt;&lt; max_val &lt;&lt; &quot; &quot; &lt;&lt; min_val &lt;&lt; endl; return 0;&#125; 三个骰子题目描述： 掷三个骰子，计算点数和。 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int sum = a + b + c; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 顺序题目显示屏题目描述： 模拟数字显示屏，用字符画显示数字。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string num; cin &gt;&gt; num; // 数字的字符画表示 string digits[10][5] = &#123; &#123;&quot;###&quot;, &quot;# #&quot;, &quot;# #&quot;, &quot;# #&quot;, &quot;###&quot;&#125;, // 0 &#123;&quot; #&quot;, &quot; #&quot;, &quot; #&quot;, &quot; #&quot;, &quot; #&quot;&#125;, // 1 &#123;&quot;###&quot;, &quot; #&quot;, &quot;###&quot;, &quot;# &quot;, &quot;###&quot;&#125;, // 2 &#123;&quot;###&quot;, &quot; #&quot;, &quot;###&quot;, &quot; #&quot;, &quot;###&quot;&#125;, // 3 &#123;&quot;# #&quot;, &quot;# #&quot;, &quot;###&quot;, &quot; #&quot;, &quot; #&quot;&#125;, // 4 &#123;&quot;###&quot;, &quot;# &quot;, &quot;###&quot;, &quot; #&quot;, &quot;###&quot;&#125;, // 5 &#123;&quot;###&quot;, &quot;# &quot;, &quot;###&quot;, &quot;# #&quot;, &quot;###&quot;&#125;, // 6 &#123;&quot;###&quot;, &quot; #&quot;, &quot; #&quot;, &quot; #&quot;, &quot; #&quot;&#125;, // 7 &#123;&quot;###&quot;, &quot;# #&quot;, &quot;###&quot;, &quot;# #&quot;, &quot;###&quot;&#125;, // 8 &#123;&quot;###&quot;, &quot;# #&quot;, &quot;###&quot;, &quot; #&quot;, &quot;###&quot;&#125; // 9 &#125;; // 输出每一行 for (int row = 0; row &lt; 5; row++) &#123; for (char c : num) &#123; cout &lt;&lt; digits[c - &#x27;0&#x27;][row] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 彩票题目描述： 模拟彩票开奖，判断中奖情况。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;int&gt; winning(7); vector&lt;int&gt; ticket(7); // 输入中奖号码 for (int i = 0; i &lt; 7; i++) &#123; cin &gt;&gt; winning[i]; &#125; // 输入彩票号码 for (int i = 0; i &lt; 7; i++) &#123; cin &gt;&gt; ticket[i]; &#125; // 统计匹配的号码数 int matches = 0; for (int i = 0; i &lt; 7; i++) &#123; if (find(winning.begin(), winning.end(), ticket[i]) != winning.end()) &#123; matches++; &#125; &#125; cout &lt;&lt; matches &lt;&lt; endl; return 0;&#125; 工艺品制作题目描述： 计算制作工艺品所需的材料数量。 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int total = n * m * k; cout &lt;&lt; total &lt;&lt; endl; return 0;&#125; 常用算法模板1. 二分查找12345678910int binarySearch(vector&lt;int&gt;&amp; arr, int target) &#123; int left = 0, right = arr.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; if (arr[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; return -1;&#125; 2. 快速排序123456789101112131415161718void quickSort(vector&lt;int&gt;&amp; arr, int left, int right) &#123; if (left &gt;= right) return; int pivot = arr[left]; int i = left, j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++; if (i &lt; j) swap(arr[i], arr[j]); &#125; arr[left] = arr[i]; arr[i] = pivot; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125; 3. 深度优先搜索12345678910void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;bool&gt;&amp; visited, int node) &#123; visited[node] = true; cout &lt;&lt; node &lt;&lt; &quot; &quot;; for (int neighbor : graph[node]) &#123; if (!visited[neighbor]) &#123; dfs(graph, visited, neighbor); &#125; &#125;&#125; 4. 广度优先搜索1234567891011121314151617181920void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start) &#123; vector&lt;bool&gt; visited(graph.size(), false); queue&lt;int&gt; q; q.push(start); visited[start] = true; while (!q.empty()) &#123; int node = q.front(); q.pop(); cout &lt;&lt; node &lt;&lt; &quot; &quot;; for (int neighbor : graph[node]) &#123; if (!visited[neighbor]) &#123; visited[neighbor] = true; q.push(neighbor); &#125; &#125; &#125;&#125; 5. 动态规划 - 斐波那契12345678910111213int fibonacci(int n) &#123; if (n &lt;= 1) return n; vector&lt;int&gt; dp(n + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n];&#125; 6. 字符串匹配123bool isSubstring(string s, string sub) &#123; return s.find(sub) != string::npos;&#125; 7. 素数筛法1234567891011121314vector&lt;bool&gt; sieve(int n) &#123; vector&lt;bool&gt; isPrime(n + 1, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i &lt;= n; i++) &#123; if (isPrime[i]) &#123; for (int j = i * i; j &lt;= n; j += i) &#123; isPrime[j] = false; &#125; &#125; &#125; return isPrime;&#125; 8. 最大公约数和最小公倍数123456789101112int gcd(int a, int b) &#123; while (b != 0) &#123; int temp = b; b = a % b; a = temp; &#125; return a;&#125;int lcm(int a, int b) &#123; return a / gcd(a, b) * b;&#125; 9. 进制转换1234567891011121314151617string decimalToBinary(int n) &#123; if (n == 0) return &quot;0&quot;; string result = &quot;&quot;; while (n &gt; 0) &#123; result = char(&#x27;0&#x27; + n % 2) + result; n /= 2; &#125; return result;&#125;int binaryToDecimal(string binary) &#123; int result = 0; for (char c : binary) &#123; result = result * 2 + (c - &#x27;0&#x27;); &#125; return result;&#125; 10. 排列组合123456789// 计算组合数 C(n,m)long long combination(int n, int m) &#123; if (m &gt; n - m) m = n - m; long long result = 1; for (int i = 0; i &lt; m; i++) &#123; result = result * (n - i) / (i + 1); &#125; return result;&#125;","categories":[{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://jaxon1216.github.io/tags/C/"},{"name":"洛谷","slug":"洛谷","permalink":"https://jaxon1216.github.io/tags/%E6%B4%9B%E8%B0%B7/"}]},{"title":"C++普通题集","slug":"普通题目","date":"2025-08-04T12:20:10.000Z","updated":"2025-08-14T06:28:54.324Z","comments":true,"path":"2025/08/04/普通题目/","permalink":"https://jaxon1216.github.io/2025/08/04/%E6%99%AE%E9%80%9A%E9%A2%98%E7%9B%AE/","excerpt":"","text":"普通题目集目录 编程题 函数题 程序填空 常用技巧 编程题前导零处理vector版本： 1234567891011vector&lt;int&gt; digits;while (num &gt; 0) &#123; digits.push_back(num % 10); // 存入个位（低位在前） num /= 10;&#125;// digits 中存储的顺序已经是逆序，例如：// 输入700 → digits=&#123;0,0,7&#125;// 输入123 → digits=&#123;3,2,1&#125;// 直接输出：for (int d : digits) cout &lt;&lt; d; // 输出时自动忽略前导零 字符串版本： 1234string num;cin &gt;&gt; num; // 输入 &quot;700&quot;reverse(num.begin(), num.end()); // 反转后 &quot;007&quot;cout &lt;&lt; stoi(num) &lt;&lt; endl; // stoi(&quot;007&quot;) → 7（自动忽略前导零） 向上取整12#include &lt;cmath&gt;ceil(2.4) // 得到3 字符函数使用相关函数集： 函数名 功能描述 isdigit() 检查数字字符（0-9） isalnum() 检查字母或数字字符 islower() 检查小写字母（a-z） isupper() 检查大写字母（A-Z） isspace() 检查空白字符（空格&#x2F;制表符等） ispunct() 检查标点符号 isprint() 检查可打印字符 常见错误： 1234567891011// 错误：stoi(c) 不能用于单个字符for(char c : s)&#123; if(isdigit(c))&#123; sum += stoi(c); // 错误！ cnt++; &#125;&#125;// 正确：需要将字符转换为数字int num = c - &#x27;0&#x27;; // 字符转数字sum += num; 二维数组转置12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; // 定义原始矩阵和转置矩阵的vector vector&lt;vector&lt;int&gt;&gt; original(m, vector&lt;int&gt;(n)); vector&lt;vector&lt;int&gt;&gt; transposed(n, vector&lt;int&gt;(m)); // 读取原始矩阵 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; original[i][j]; &#125; &#125; // 进行转置 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; transposed[j][i] = original[i][j]; &#125; &#125; // 输出转置后的矩阵，每个数据占5列 for (const auto&amp; row : transposed) &#123; for (int num : row) &#123; cout &lt;&lt; setw(5) &lt;&lt; num; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 杨辉三角1234567891011121314#include&lt;iostream&gt;using namespace std;long long a,b[100][100];int main() &#123; cin&gt;&gt;a; b[1][1]=1; for(int i=1;i&lt;=a;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; b[i][j]+=b[i-1][j-1]+b[i-1][j]; cout&lt;&lt;b[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 回文判断123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); string s1 = s; reverse(s1.begin(),s1.end()); if(s1 == s) cout &lt;&lt; s &lt;&lt; &quot;是回文&quot;; else cout &lt;&lt; s &lt;&lt; &quot;不是回文&quot;; return 0;&#125; 字符统计12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; cnt(10,0); // 注意初始化大小 string s; cin &gt;&gt; s; for(int i = 0; i &lt; s.size(); i++)&#123; cnt[s[i]- &#x27;0&#x27;]++; // 注意字符转数字 &#125; for(int i = 0; i &lt; cnt.size(); i++)&#123; if(cnt[i]!=0)&#123; cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; cnt[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 外卖费用计算123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int n; char m; cin &gt;&gt; n &gt;&gt; m; int a = n / 500; // 关键是那句不足500克按500克收就这样方便 if(n % 500 != 0) a++; // 模拟 int b = 4 + 3 * (a - 2); // 模拟知道这里是-2 if(n &lt;= 1000) b = 4; // 这句是为了防止n小于500的情况 if(m == &#x27;y&#x27;) b += 5; cout &lt;&lt; b &lt;&lt; endl; return 0;&#125; 天天向上123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double d; cin &gt;&gt; d; if(d &gt;= 0) cout &lt;&lt; &quot;up:&quot;&lt;&lt;fixed &lt;&lt; setprecision(2) &lt;&lt; (pow(1+d,365)-1)*100 &lt;&lt; &quot;%&quot;; if(d &lt; 0) cout &lt;&lt; &quot;down:&quot;&lt;&lt;fixed &lt;&lt; setprecision(2) &lt;&lt; (-pow(1-abs(d),365)+1)*100 &lt;&lt; &quot;%&quot;; return 0;&#125; 三天打鱼两天晒网1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int r = n % 5; if (r == 1 || r == 2 || r == 3) &#123; cout &lt;&lt; &quot;Fishing in day &quot; &lt;&lt; n &lt;&lt; endl; &#125; else &#123; // 余数为0或4的情况 cout &lt;&lt; &quot;Drying in day &quot; &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125; 日期计算1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main() &#123; int year, month, day; cin &gt;&gt; year &gt;&gt; month &gt;&gt; day; // 预定义每月天数（2月按平年计算） int days[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; // 处理闰年 if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) &#123; days[2] = 29; &#125; int total = day; for (int i = 1; i &lt; month; i++) &#123; total += days[i]; &#125; cout &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; setw(4) &lt;&lt; year &lt;&lt; &quot;-&quot; &lt;&lt; setw(2) &lt;&lt; month &lt;&lt; &quot;-&quot; &lt;&lt; setw(2) &lt;&lt; day &lt;&lt; &quot;:&quot; &lt;&lt; total &lt;&lt; endl; return 0;&#125; 数组最大值最小值交换1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; shuzi(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; shuzi[i]; auto max = max_element(shuzi.begin(), shuzi.end()); auto min = min_element(shuzi.begin(), shuzi.end()); int maxweizhi = distance(shuzi.begin(), max); int minweizhi = distance(shuzi.begin(), min); swap(shuzi[maxweizhi], shuzi[minweizhi]); cout &lt;&lt; &quot;max = &quot; &lt;&lt; *max &lt;&lt; &quot;, min = &quot; &lt;&lt; *min &lt;&lt; endl; for(int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; shuzi[i]; if(i != n-1) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 菱形打印1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; // 打印上半部分（包括中间行） for(int i = 0; i &lt; n / 2 + 1; i++)&#123; for(int j = 0; j &lt; n / 2 - i; j++) cout &lt;&lt; &quot; &quot;; for(int j = 0; j &lt; 2 * i + 1; j++) cout &lt;&lt; &quot;*&quot;; cout &lt;&lt; endl; &#125; // 打印下半部分 for(int i = n / 2 - 1; i &gt;= 0; i--)&#123; for(int j = 0; j &lt; n / 2 - i; j++) cout &lt;&lt; &quot; &quot;; for(int j = 0; j &lt; 2 * i + 1; j++) cout &lt;&lt; &quot;*&quot;; cout &lt;&lt; endl; &#125; return 0;&#125; 回文质数123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;// 素数判断函数bool sushu(int n) &#123; if (n &lt;= 1) return false; // 1不是素数 for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125;// 数字反转int fanzhuan(int n)&#123; int temp = n, ans = 0; while (temp != 0) &#123; ans = ans * 10 + temp % 10; temp /= 10; &#125; return ans;&#125;int main() &#123; int m, n, ans = 0; cin &gt;&gt; m &gt;&gt; n; for (int i = m; i &lt;= n; i++) &#123; if (sushu(i) &amp;&amp; sushu(fanzhuan(i))) ans++; &#125; cout &lt;&lt; ans; return 0;&#125; 函数题二维数组行最大值与列最小值的平均值12345678910111213141516171819202122232425262728double Average(double a[][M], int n) &#123; double sum = 0; // 计算每行的最大值并累加到总和 for (int i = 0; i &lt; n; i++) &#123; double max = a[i][0]; for (int j = 1; j &lt; M; j++) &#123; if (a[i][j] &gt; max) &#123; max = a[i][j]; &#125; &#125; sum += max; &#125; // 计算每列的最小值并累加到总和 for (int j = 0; j &lt; M; j++) &#123; double min = a[0][j]; for (int i = 1; i &lt; n; i++) &#123; if (a[i][j] &lt; min) &#123; min = a[i][j]; &#125; &#125; sum += min; &#125; // 返回平均值 return sum / (n + M);&#125; 最大公约数（辗转相除法）12345678int gcd(int a, int b) &#123; while (b != 0) &#123; int t = b; b = a % b; a = t; &#125; return a;&#125; 素数判断1234567bool isPrime(int n) &#123; if (n &lt;= 1) return false; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return false; &#125; return true;&#125; 斐波那契数列1234567void fibo(int n, int f[]) &#123; f[0] = 0; f[1] = 1; for (int i = 2; i &lt; n; i++) &#123; f[i] = f[i-1] + f[i-2]; &#125;&#125; 字符串反转12345678void reverse(char str[]) &#123; int len = strlen(str); for (int i = 0; i &lt; len / 2; i++) &#123; char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; &#125;&#125; 数组排序1234567891011void sort(int arr[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 程序填空1. Student类填空题123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Student&#123;public: Student(int i_id, char i_name[]); int getId();private: int id; char name[20];&#125;;Student::Student(int i_id, char i_name[])&#123; id = i_id; strcpy(name, i_name); // 【1】必须使用strcpy进行字符串深拷贝&#125;int Student::getId()&#123; return id; // 【2】返回私有成员id的值&#125;int main()&#123; Student s1(1, &quot;zhangsan&quot;); cout &lt;&lt; s1.getId() &lt;&lt; endl; // 【3】成员函数调用必须带括号&#125; 2. Complex类填空题1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Complex&#123;public: Complex() &#123; Set(0,0); &#125; Complex(double r, double i); void Set(double r, double i); void Output(); double GetReal() &#123; return real; &#125; double GetImag() &#123; return imag; &#125;private: double real, imag;&#125;;Complex::Complex(double r, double i) // 【1】类外定义需作用域解析符和完整参数类型&#123; Set(r, i);&#125;int main()&#123; Complex p2(1,2); cout &lt;&lt; p2.GetReal() &lt;&lt; &quot;+&quot; &lt;&lt; p2.GetImag() &lt;&lt; &quot;i&quot; &lt;&lt; endl; // 【2】成员函数调用需注意大小写一致&#125; 3. 冒泡排序填空题123456789101112void BubbleSort(int a[],int n)&#123; int i,j; for(j=0;j&lt;n;j++) // 【1】外层循环变量初始化 for(i=0;i&lt;n-j-1;i++) // 【2】每轮减少比较次数 if(a[i] &gt; a[i+1]) // 【3】升序排序条件 &#123; int t=a[i]; a[i] = a[i+1]; // 【4】元素交换操作 a[i+1]=t; &#125; &#125; 4. 选择排序填空题12345678910111213for(k = 0; k &lt; n-1; k++)&#123; // 【1】需n-1轮选择 index = k; // 【2】初始化最大值位置 for(i = k+1; i &lt; n; i++) // 【3】遍历未排序部分 &#123; if(a[i] &gt; a[index]) // 【4】找更大值条件 &#123; index = i; // 【5】更新最大值索引 &#125; &#125; temp = a[index]; a[index] = a[k]; a[k] = temp;&#125; 5. 二维数组对称判断12345678910for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(a[i][j] != a[j][i]) // 【1】对称判断条件 &#123; found = 0; // 【2】发现不对称时标记 break; &#125; &#125; if(found == 0) break; // 【3】发现不对称提前退出&#125; 6. 有序插入字符12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;void insertString(char str[], char c); // 【1】函数前置声明int main()&#123; char str[100],c; cin.getline(str,99); cin&gt;&gt;c; insertString(str, c); // 【2】函数调用 cout&lt;&lt;str&lt;&lt;endl;&#125;void insertString (char str[], char c)&#123; int n,i; for(n=0;str[n]!=0;n++); str[n+1]=&#x27;\\0&#x27;; for(i = n-1;i&gt;=0;i--) // 【3】从末尾开始遍历 if(str[i]&gt;c) str[i+1] = str[i] // 【4】元素后移操作 else break; str[i+1] = c; // 【5】在正确位置插入字符&#125; 7. Circle类填空题123456789class Circle&#123;public: // 【1】公共访问权限 double m_r; // 【2】定义半径属性 double calculateZC() &#123; return 2 * PI * m_r; // 【3】圆周长公式 &#125;&#125;; 8. 类的权限控制1234567891011class Person&#123;public: void setmycar(string a) &#123; m_Car = a; &#125; // 【1】保护属性设置方法 void setpassword(int a) &#123; m_Password = a; &#125; // 【2】私有属性设置方法&#125;;int main() &#123; Person p; cout &lt;&lt; p.m_Name &lt;&lt; endl; // 【3】公共属性直接访问&#125; 9. 类的读写控制123456789101112class Person &#123;public: // 姓名可读可写 void setName(string name) &#123; m_Name = name; &#125; // 【1】【2】设置姓名 string getName() &#123; return m_Name; &#125; // 【3】【4】获取姓名 // 暗恋对象只写 void setLover(string lover) &#123; m_Lover = lover; &#125; // 【5】【6】设置暗恋对象 // 所在地只读 string getip() &#123; return ip; &#125; // 【7】【8】获取所在地&#125;; 10. Circle类构建123456789class Circle &#123; // 【1】类名public: Circle(double ir); // 【2】构造函数参数 void setR(double ir); // 【3】设置半径方法 double getArea(); // 【4】获取面积方法&#125;;Circle::Circle(double ir)&#123; r=ir; &#125; // 【5】构造函数参数double getArea()&#123; return 3.14*r*r; &#125; // 【6】返回类型 11. Time类123Time::Time(int h=0, int m=0, int s=0) &#123; setTime(h,m,s); &#125; // 【1】构造函数默认参数void Time::setTime(int h,int m,int s) &#123; hour=h; min=m; sec=s; &#125; // 【2】类外实现作用域int Time::getHour() &#123; return hour; &#125; // 【3】返回私有成员值 常用技巧1. 连续输出文本123456cout &lt;&lt; &quot; ********\\n&quot;&quot; ************\\n&quot;&quot; ####....#.\\n&quot;&quot; #..###.....##....\\n&quot;&quot; ###.......###### ### ###\\n&quot;; 2. 浮点数精度控制123456#include &lt;iomanip&gt;double t;int n;cin &gt;&gt; t &gt;&gt; n;double perStudent = t / n;cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; perStudent &lt;&lt; endl; 3. 字符串反转1234567#include &lt;string&gt;#include &lt;algorithm&gt;string a;cin &gt;&gt; a;reverse(a.begin(), a.end()); // 反转字符串cout &lt;&lt; a &lt;&lt; endl; 4. 字符大小写转换123456789101112// 方法1：ASCII码计算char s;cin &gt;&gt; s;char m = s - (&#x27;a&#x27; - &#x27;A&#x27;); // 小写转大写cout &lt;&lt; m &lt;&lt; endl;// 方法2：使用函数#include &lt;cctype&gt;char c;cin &gt;&gt; c;c = toupper(c); // 转换为大写cout &lt;&lt; c &lt;&lt; endl; 5. 闰年判断123bool isLeapYear(int year) &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);&#125; 6. 向上取整123#include &lt;cmath&gt;double v = 3.14 * r * r * h;int n = ceil(20000.0 / v); 7. 字符串转数字123string s = &quot;123&quot;;int num = stoi(s); // 字符串转整数double d = stod(s); // 字符串转浮点数 8. 数字转字符串12int num = 123;string s = to_string(num); // 数字转字符串 9. 数组初始化1234567// 一维数组int arr[10] = &#123;0&#125;; // 全部初始化为0vector&lt;int&gt; vec(10, 0); // vector初始化// 二维数组int arr[3][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;vector&lt;vector&lt;int&gt;&gt; vec(3, vector&lt;int&gt;(3, 0)); 10. 常用算法函数1234567891011121314#include &lt;algorithm&gt;// 排序sort(vec.begin(), vec.end());// 反转reverse(vec.begin(), vec.end());// 查找最大最小值auto max_it = max_element(vec.begin(), vec.end());auto min_it = min_element(vec.begin(), vec.end());// 交换swap(a, b);","categories":[{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://jaxon1216.github.io/tags/C/"},{"name":"题目集","slug":"题目集","permalink":"https://jaxon1216.github.io/tags/%E9%A2%98%E7%9B%AE%E9%9B%86/"}]}],"categories":[{"name":"diary","slug":"diary","permalink":"https://jaxon1216.github.io/categories/diary/"},{"name":"study","slug":"study","permalink":"https://jaxon1216.github.io/categories/study/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://jaxon1216.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"资料","slug":"资料","permalink":"https://jaxon1216.github.io/tags/%E8%B5%84%E6%96%99/"},{"name":"资料汇总","slug":"资料汇总","permalink":"https://jaxon1216.github.io/tags/%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"},{"name":"学习资源","slug":"学习资源","permalink":"https://jaxon1216.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"},{"name":"编程","slug":"编程","permalink":"https://jaxon1216.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"数学建模","slug":"数学建模","permalink":"https://jaxon1216.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"英语","slug":"英语","permalink":"https://jaxon1216.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"保研","slug":"保研","permalink":"https://jaxon1216.github.io/tags/%E4%BF%9D%E7%A0%94/"},{"name":"C++","slug":"C","permalink":"https://jaxon1216.github.io/tags/C/"},{"name":"洛谷","slug":"洛谷","permalink":"https://jaxon1216.github.io/tags/%E6%B4%9B%E8%B0%B7/"},{"name":"题目集","slug":"题目集","permalink":"https://jaxon1216.github.io/tags/%E9%A2%98%E7%9B%AE%E9%9B%86/"}]}